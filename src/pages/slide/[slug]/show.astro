---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "@/layouts/Layout.astro";
import { renderMarpSlides } from "@/utils/marp";
import type { ImageMetadata } from "astro";
import "@/styles/show.css";
import { Button } from "@/components/ui/Button";
import { ReadingMode } from "@/icons/ReadingMode";
import { ArrowPrevious } from "@/icons/ArrowPrevious";
import { ArrowNext } from "@/icons/ArrowNext";
import { FullscreenMaximize } from "@/icons/FullscreenMaximize";

// Import all images from src/assets using Vite's glob import
const images = import.meta.glob<{ default: ImageMetadata }>(
  "/src/assets/**/*.{jpeg,jpg,png,gif,webp}",
  { eager: true },
);

export async function getStaticPaths() {
  const slides = await getCollection("slide");
  return slides.map((slide) => ({
    params: { slug: slide.slug },
    props: { slide },
  }));
}

type Props = {
  slide: CollectionEntry<"slide">;
};

const { slide } = Astro.props;

// Create image path mapping for Vite assets
const imageMapping: Record<string, string> = {};
for (const [path, module] of Object.entries(images)) {
  // Extract filename from the import path
  const filename = path.split("/").pop();
  if (filename) {
    imageMapping[filename] = module.default.src;
  }
}

const marpResult = renderMarpSlides(slide.body, imageMapping);
---

<Layout title={slide.data.title} description={slide.data.description}>
  <style set:html={marpResult.css}></style>

  <!-- Slideshow Presentation View -->
  <div class="slideshow-container">
    <div
      class="slideshow-controls fixed bottom-5 right-5 z-30 flex gap-3 items-center backdrop-blur-sm transition-all spring-bounce-10 spring-duration-200 pointer-events-auto p-3 rounded-md overflow-hidden bg-primary-bg/50"
    >
      <Button id="prev-slide" class="cursor-pointer"
        ><ArrowPrevious class="size-4" /></Button
      >
      <span id="slide-counter">1 / {marpResult.slides.length}</span>
      <Button id="next-slide" class="cursor-pointer"
        ><ArrowNext class="size-4" /></Button
      >
      <Button href={`/slide/${slide.slug}`}
        ><ReadingMode class="size-4" /></Button
      >
      <Button id="fullscreen" class="cursor-pointer"
        ><FullscreenMaximize class="size-4" /></Button
      >
    </div>

    <div class="slide-viewport marpit">
      {
        marpResult.slides.map((slideItem, index) => (
          <svg
            class={`slide ${index === 0 ? "active" : ""}`}
            data-marpit-svg=""
            viewBox="0 0 1280 720"
          >
            <foreignObject width="1280" height="720">
              <section data-slide-index={index} set:html={slideItem.html} />
            </foreignObject>
          </svg>
        ))
      }
    </div>
  </div>

  <script>
    let currentSlide = 0;
    const slides = document.querySelectorAll(".slide");
    const totalSlides = slides.length;
    const counter = document.getElementById("slide-counter");
    const prevBtn = document.getElementById("prev-slide");
    const nextBtn = document.getElementById("next-slide");
    const controls = document.querySelector(
      ".slideshow-controls",
    ) as HTMLElement;

    let controlsTimeout: number | null = null;

    function showSlide(index: number) {
      // Find currently active slide
      const currentActiveSlide = document.querySelector(".slide.active");
      const targetSlide = slides[index];

      if (currentActiveSlide && currentActiveSlide !== targetSlide) {
        // Start exit animation for current slide
        currentActiveSlide.classList.add("slide-exiting");

        // After exit animation completes, hide current and show new slide
        setTimeout(() => {
          currentActiveSlide.classList.remove("active", "slide-exiting");
          targetSlide.classList.add("active", "slide-entering");

          // Remove entering class after animation completes
          setTimeout(() => {
            targetSlide.classList.remove("slide-entering");
          }, 300);
        }, 150);
      } else {
        // First slide or same slide, show immediately
        slides.forEach((slide, i) => {
          slide.classList.toggle("active", i === index);
        });
      }

      if (counter) {
        counter.textContent = `${index + 1} / ${totalSlides}`;
      }
    }

    function nextSlide() {
      currentSlide = (currentSlide + 1) % totalSlides;
      showSlide(currentSlide);
    }

    function prevSlide() {
      currentSlide = (currentSlide - 1 + totalSlides) % totalSlides;
      showSlide(currentSlide);
    }

    // Auto-hide controls functionality
    function showControls() {
      if (controls) {
        controls.style.transform = "translateY(0)";
        controls.style.opacity = "1";
        controls.style.pointerEvents = "auto";
      }
    }

    function hideControls() {
      if (controls) {
        controls.style.transform = "translateY(50%)";
        controls.style.opacity = "0";
        controls.style.pointerEvents = "none";
      }
    }

    function resetControlsTimer() {
      // Clear existing timeout
      if (controlsTimeout) {
        clearTimeout(controlsTimeout);
      }

      // Show controls
      showControls();

      // Set new timeout to hide controls after 3 seconds
      controlsTimeout = window.setTimeout(() => {
        hideControls();
      }, 3000);
    }

    // Initialize controls and start timer
    showControls();
    resetControlsTimer();

    function fullscreenHandler() {
      const slideshowContainer = document.querySelector(".slideshow-container");
      if (!slideshowContainer) return;

      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        slideshowContainer.requestFullscreen();
      }
    }

    const fullscreenBtn = document.getElementById("fullscreen");
    if (fullscreenBtn) {
      fullscreenBtn.addEventListener("click", fullscreenHandler);
    }

    // Event listeners for user interaction
    document.addEventListener("mousemove", resetControlsTimer);
    document.addEventListener("click", resetControlsTimer);

    // Button event listeners
    if (nextBtn) {
      nextBtn.addEventListener("click", nextSlide);
    }
    if (prevBtn) {
      prevBtn.addEventListener("click", prevSlide);
    }

    // Enhanced keyboard navigation
    document.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowRight":
        case "ArrowDown":
        case " ":
          e.preventDefault();
          nextSlide();
          break;
        case "ArrowLeft":
        case "ArrowUp":
          e.preventDefault();
          prevSlide();
          break;
        case "Home":
          e.preventDefault();
          currentSlide = 0;
          showSlide(currentSlide);
          resetControlsTimer();
          break;
        case "End":
          e.preventDefault();
          currentSlide = totalSlides - 1;
          showSlide(currentSlide);
          resetControlsTimer();
          break;
        case "Escape":
          // Go back to document view
          window.location.href = `/slide/${window.location.pathname.split("/")[2]}`;
          break;
      }
    });
  </script>
</Layout>
